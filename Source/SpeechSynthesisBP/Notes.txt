Manually adding blueprint macros to a project seems to break subsequent C++ builds or are just ignored by the UE INI pkg compiler!
Adding custom blueprints as C++ compenents in the UE event graph seems to work fine. Each blueprint class is then compiled as a separate implementation file.
It appears verbals consonats and vowels carry the most information in speech. The library should be able to generate these sounds with a high degree of delineation.

Circular convolution on a pair of finite length signals can be accomplished by performing a fast fourier transform on the signals, 
multiplying them (in the Frequency domain), performing an inverse fourier transform on the signal, and then scaling them by the bit-depth-per-sample 
(ie. the N bit dynamic range) to avoid clipping (lossy).

BitDepthPerSample = 16; Encodes 2^16 = 65536 possible amplitude values per sample.
SampleRate = 44100; Encodes 44100 frequency values per sample per second. Nyquist frequency is 22050 Hz. (Human hearing range is 20 Hz to 20 kHz.)

If I intend to rely on Spectrograms for their realism versus signal formants because of their computational simplicity and ease of use, 
I should consider using Generative Adversarial Networks (GANs) to generate the spectrograms from a set of training data.

Source Signal matching involves several components: amplitude, phase, frequency, wave-shape, duration, noise-type

sin approximation (performance)

```cpp
    float approximate_sin_f(const float x)
    {
        // Calculate 2 PI inverse (once)
        const float inverse_2pi_ConstFloat32 = 1 / 2 * PI;

        // Calculate t_step_float32 
        float t_step_float32 = x * inverse_2pi_ConstFloat32;

        // Wrap t_step_float32 to fit [0, 1]
        t_step_float32 = t_step_float32 - static_cast<int>(t_step_float32);

        // Calculate sin(x) using a quadratic approximation cf. square wave (eg. pipe organ)
        return (t_step_float32 < 0.5f) ? 
        -16 * t_step_float32 * t_step_float32 + 8 * t_step_float32 :    // positive half
            16 * t_step_float32 * t_step_float32 - 8 * t_step_float32 + 8; // negative half

        // Calculate sin(x) using a cubic approximation cf. sawtooth (eg. flutish)
        /*
        return 20.785f * (t_step_float32  - 0.0f) * (t_step_float32  - 0.5f) * (t_step_float32  - 1.0f);
        */
    }
```

Consider convolutin a weighted moving average or smoothing filter (cf. statistics).

